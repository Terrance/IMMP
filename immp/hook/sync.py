"""
Bridge multiple channels into a single unified conversation.

Config:
    channels ((str, str list) dict):
        Mapping from virtual channel names to lists of channel names to bridge.
    plug (str):
        Name of a virtual plug to register for this sync.
    joins (bool):
        Whether to sync join and part messages across the bridge.
    renames (bool):
        Whether to sync channel title changes across the bridge.
    identities (str):
        Name of a registered :class:`.IdentityHook` to provide unified names across networks.
    name-format(str):
        Template to use for replacing real names on synced messages, parsed by :mod:`jinja2`.  If
        not set but the user is identified, it defaults to ``<real name> (<identity name>)``.

        Available variables are ``user`` (:class:`.User`) and ``identity`` (if enabled as above --
        :class:`.IdentityGroup`, or ``None`` if no link).

Commands:
    sync-members:
        List all members of the current conversation, across all channels.
    sync-list:
        List all channels connected to this conversation.

When a message is received from any of the listed channels, a copy is pushed to all other channels
participating in the bridge.

If ``plug`` is specified, a virtual plug is registered under that name, with a channel for each
defined bridge.  Other hooks may reference these channels, to work with all channels in that sync
as one.  This allows them to listen to a unified stream of messages, or push new messages to all
synced channels.

.. note::
    Use of ``name-format`` requires the `Jinja2 <http://jinja.pocoo.org>`_ Python module.
"""

from asyncio import BoundedSemaphore, gather
from collections import defaultdict
from copy import copy
import logging

from peewee import CharField
from voluptuous import ALLOW_EXTRA, Any, Optional, Schema

import immp
from immp.hook.command import command
from immp.hook.database import BaseModel, DatabaseHook
from immp.hook.identity import IdentityHook


try:
    from jinja2 import Template
except ImportError:
    Template = None


log = logging.getLogger(__name__)


class _Schema:

    config = Schema({"channels": {str: [str]},
                     Optional("plug", default=None): Any(str, None),
                     Optional("joins", default=True): bool,
                     Optional("renames", default=True): bool,
                     Optional("identities", default=None): Any(str, None),
                     Optional("name-format", default=None): Any(str, None)},
                    extra=ALLOW_EXTRA, required=True)


class SyncBackRef(BaseModel):
    """
    One of a set of references, each pointing to a representation of a source message.

    Attributes:
        key (str):
            Shared ID for each message in the same set.
        network (str):
            Network identifier of the plug for this message.
        channel (str):
            Origin channel of the referenced message.
        message (str):
            Message ID as generated by the plug.
    """

    key = CharField()
    network = CharField()
    channel = CharField()
    message = CharField()

    class Meta:
        # Unique constraint for each message.
        indexes = ((("network", "channel", "message"), True),)

    @classmethod
    def map_from_sent(cls, sent):
        """
        Take a :class:`.SentMessage` and attempt to resolve it to a key from a previously synced
        reference, then defer to :meth:`map_from_key` to make the mapping with the key.

        Args:
            sent (.SentMessage):
                Referenced message to lookup.

        Returns:
            ((str, str), .SyncBackRef) dict:
                Generated reference mapping.
        """
        alias = cls.alias()
        key = alias.select(alias.key).where(alias.network == sent.channel.plug.network_id,
                                            alias.channel == sent.channel.source,
                                            alias.message == str(sent.id))
        return cls.map_from_key(key)

    @classmethod
    def map_from_key(cls, key):
        """
        For a given key, fetch all messages references synced from the corresponding source, and
        group them by network and channel.

        Args:
            key (str):
                Synced message identifier.

        Returns:
            ((str, str), .SyncBackRef) dict:
                Generated reference mapping.
        """
        backrefs = cls.select().where(cls.key == key)
        if not backrefs:
            raise KeyError
        mapped = defaultdict(list)
        for backref in backrefs:
            mapped[(backref.network, backref.channel)].append(backref)
        return backref.key, mapped

    def __repr__(self):
        return "<{}: #{} {} {} @ {}/{}>".format(self.__class__.__name__, self.id, self.key,
                                                self.message, self.network, self.channel)


class SyncRef:
    """
    Representation of a single synced message.

    Attributes:
        key (str):
            Unique synced message identifier, used by :class:`.SyncPlug` when yielding messages.
        ids ((.Channel, str) dict):
            Mapping from :class:`.Channel` to a list of echoed message IDs.
        revisions ((.Channel, (str, set) dict) dict):
            Mapping from :class:`.Channel` to message ID to synced revisions of that message.
        source (.Message):
            Original copy of the source message, if we have it.
    """

    next_key = immp.IDGen()

    @classmethod
    def from_backref_map(cls, key, mapped, host):
        """
        Take a mapping generated in :meth:`.SyncBackRef.map_from_key` and produce a local reference
        suitable for the memory cache.

        Args:
            key (str):
                Synced message identifier.
            mapped (((str, str), .SyncBackRef list) dict):
                Generated reference mapping.
            host (.Host):
                Parent host instance, needed to resolve network IDs to plugs.

        Returns:
            .SyncRef:
                Newly created reference.
        """
        ids = {}
        for (network, source), synced in mapped.items():
            for plug in host.plugs.values():
                if plug.network_id == network:
                    ids[immp.Channel(plug, source)] = [backref.message for backref in synced]
        return cls(ids, key=key)

    def __init__(self, ids, *, key=None, source=None, origin=None):
        self.key = key or self.next_key()
        self.ids = defaultdict(list, ids)
        self.revisions = defaultdict(lambda: defaultdict(set))
        self.source = source
        if origin:
            self.ids[origin.channel].append(origin.id)
            self.revision(origin)

    def revision(self, sent):
        """
        Log a new revision of a message.

        Args:
            sent (.SentMessage):
                Updated message relating to a previously synced message.

        Returns:
            bool:
                ``True`` if this is an edit (i.e. we've already seen a base revision for this
                message) and needs syncing to other channels.
        """
        self.revisions[sent.channel][sent.id].add(sent.revision)
        return len(self.revisions[sent.channel][sent.id]) > 1

    def __repr__(self):
        return "<{}: #{} x{}{}>".format(self.__class__.__name__, self.key, len(self.ids),
                                        " {}".format(repr(self.source)) if self.source else "")


class SyncCache:
    """
    Synced message cache manager, using both in-memory and database-based caches.

    This class has :class:`dict`-like access, using either :class:`.SentMessage` objects or
    :class:`.SyncPlug` message IDs that map to :class:`.SyncRef` keys.
    """

    def __init__(self, hook):
        self._hook = hook
        self._cache = {}
        # Reverse mapping, Channel -> ID -> SyncRef.
        self._lookup = defaultdict(dict)

    def add(self, ref, back=False):
        """
        Add a :class:`.SyncRef` to the cache.  This will also commit a new :class:`.SyncBackRef` to
        the database if configured.

        Args:
            ref (.SyncRef):
                Newly synced message to store.
            back (bool):
                ``True`` if sourced from a :class:`.SyncBackRef`, and therefore doesn't need
                committing back to the database.

        Returns:
            .SyncRef:
                The same ref, useful for shorthand add-then-return.
        """
        self._cache[ref.key] = ref
        data = []
        for channel, ids in ref.ids.items():
            for id in ids:
                self._lookup[channel][id] = ref.key
                data.append({"key": ref.key, "network": channel.plug.network_id,
                             "channel": channel.source, "message": id})
        if self._hook.db and not back:
            SyncBackRef.insert_many(data).on_conflict("ignore").execute()
        return ref

    def __getitem__(self, key):
        if isinstance(key, immp.SentMessage):
            try:
                # If in the local cache, the message already passed through sync in this session.
                # Use the existing cache entry as-is (entry in _lookup <=> entry in _cache).
                return self._cache[self._lookup[key.channel][key.id]]
            except KeyError:
                if not self._hook.db:
                    raise
            # Not cached locally, but the database is configured: check there for a reference,
            # build a new SyncRef with an empty source, and cache it.
            key, mapped = SyncBackRef.map_from_sent(key)
            return self.add(SyncRef.from_backref_map(key, mapped, self._hook.host), True)
        elif isinstance(key, str):
            # As above, check the local cache directly first.
            try:
                return self._cache[key]
            except KeyError:
                if not self._hook.db:
                    raise
            # Now check the database for the key.
            _, mapped = SyncBackRef.map_from_key(key)
            return self.add(SyncRef.from_backref_map(key, mapped, self._hook.host), True)
        else:
            raise TypeError(key)

    def __repr__(self):
        return "<{}: {} refs>".format(self.__class__.__name__, len(self._cache))


class SyncPlug(immp.Plug):
    """
    Virtual plug that allows sending external messages to a synced conversation.
    """

    network_name = "Sync"

    @property
    def network_id(self):
        return "sync:{}".format(self.name)

    def __init__(self, name, hook, host):
        super().__init__(name, hook.config, host, virtual=True)
        self._hook = hook

    @classmethod
    def any_sync(cls, host, channel):
        """
        Produce a synced channel for the given source, searching across all :class:`.SyncPlug`
        instances running on the host.

        Args:
            host (.Host):
                Controlling host instance.
            channel (.Channel):
                Original channel to lookup.

        Returns:
            .Channel:
                Sync channel containing the given channel as a source, or ``None`` if not synced.
        """
        synced = [plug.sync_for(channel) for plug in host.plugs.values() if isinstance(plug, cls)]
        try:
            return next(filter(None, synced))
        except StopIteration:
            return None

    def sync_for(self, channel):
        """
        Produce a synced channel for the given source.

        Args:
            channel (.Channel):
                Original channel to lookup.

        Returns:
            .Channel:
                Sync channel containing the given channel as a source, or ``None`` if not synced.
        """
        for label, synced in self._hook.channels.items():
            if channel in synced:
                return immp.Channel(self, label)
        return None

    async def channel_is_private(self, channel):
        return False if channel.source in self.config["channels"] else None

    async def channel_members(self, channel):
        if channel.source not in self.config["channels"]:
            return None
        members = []
        for synced in self._hook.channels[channel.source]:
            members.extend(await synced.members() or [])
        return members

    async def put(self, channel, msg):
        if channel.source in self.config["channels"]:
            await self._hook.send(channel.source, msg)
            return []
        else:
            raise immp.PlugError("Send to unknown sync channel: {}".format(repr(channel)))


class SyncHook(immp.Hook):
    """
    Hook to propagate messages between two or more channels.

    Attributes:
        plug (.SyncPlug):
            Virtual plug for this sync, if configured.
    """

    def __init__(self, name, config, host):
        super().__init__(name, _Schema.config(config), host)
        # Message cache, stores IDs of all synced messages by channel.
        self._cache = SyncCache(self)
        # Hook lock, to put a hold on retrieving messages whilst a send is in progress.
        self._lock = BoundedSemaphore()
        # Add a virtual plug to the host, for external subscribers.
        if self.config["plug"]:
            log.debug("Creating virtual plug: {}".format(repr(self.config["plug"])))
            self.plug = SyncPlug(self.config["plug"], self, host)
            host.add_plug(self.plug)
            for label in self.config["channels"]:
                host.add_channel(label, immp.Channel(self.plug, label))
        else:
            self.plug = None

    @property
    def channels(self):
        try:
            return {virtual: [self.host.channels[label] for label in labels]
                    for virtual, labels in self.config["channels"].items()}
        except KeyError as e:
            raise immp.ConfigError("No channel {} on host".format(repr(e.args[0]))) from None

    def label_for_channel(self, channel):
        labels = []
        for label, channels in self.channels.items():
            if channel in channels:
                labels.append(label)
        if not labels:
            raise immp.ConfigError("Channel {} not bridged".format(repr(channel)))
        elif len(labels) > 1:
            raise immp.ConfigError("Channel {} defined more than once".format(repr(channel)))
        else:
            return labels[0]

    async def start(self):
        try:
            self.db = self.host.resources[DatabaseHook].db
        except KeyError:
            self.db = None
        else:
            self.db.create_tables([SyncBackRef], safe=True)

    @command("sync-members")
    async def members(self, msg):
        """
        List all members of the current conversation, across all channels.
        """
        members = defaultdict(list)
        missing = False
        for synced in self.channels[msg.channel.source]:
            local = (await synced.members())
            if local:
                members[synced.plug.network_name] += local
            else:
                missing = True
        if not members:
            return
        text = immp.RichText([immp.Segment("Members of this conversation:")])
        for network in sorted(members):
            text.append(immp.Segment("\n{}".format(network), bold=True))
            for member in sorted(members[network],
                                 key=lambda member: member.real_name or member.username):
                name = member.real_name or member.username
                text.append(immp.Segment("\n"))
                if member.link:
                    text.append(immp.Segment(name, link=member.link))
                elif member.real_name and member.username:
                    text.append(immp.Segment("{} [{}]".format(name, member.username)))
                else:
                    text.append(immp.Segment(name))
        if missing:
            text.append(immp.Segment("\n"),
                        immp.Segment("(list may be incomplete)"))
        await msg.channel.send(immp.Message(user=immp.User(real_name="Sync"), text=text))

    @command("sync-list")
    async def list(self, msg):
        """
        List all channels connected to this conversation.
        """
        text = immp.RichText([immp.Segment("Channels in this sync:")])
        for synced in self.channels[msg.channel.source]:
            text.append(immp.Segment("\n{}".format(synced.plug.network_name)))
            title = await synced.title()
            if title:
                text.append(immp.Segment(": {}".format(title)))
        await msg.channel.send(immp.Message(user=immp.User(real_name="Sync"), text=text))

    async def _send(self, channel, msg):
        try:
            ids = await channel.send(msg)
            log.debug("Synced IDs in {}: {}".format(repr(channel), ids))
            return (channel, ids)
        except Exception:
            log.exception("Failed to relay message to channel: {}".format(repr(channel)))
            return (channel, [])

    async def send(self, label, msg, origin=None):
        """
        Send a message to all channels in this sync.

        Args:
            label (str):
                Bridge that defines the underlying synced channels to send to.
            msg (.Message):
                External message to push.
            origin (.SentMessage):
                Raw message that triggered this sync; if set and part of the sync, it will be
                skipped (used to avoid retransmitting a message we just received).
        """
        # Note that `origin` corresponds to the enriched message (i.e. `sent` in on_receive()),
        # and `msg` refers to the canonical copy (i.e. `source`).
        clone = copy(msg)
        identity = None
        if clone.user:
            if self.config["identities"]:
                # Identities integration: show identity name on synced messages.
                try:
                    identities = self.host.hooks[self.config["identities"]]
                    if not isinstance(identities, IdentityHook):
                        raise KeyError
                except KeyError:
                    raise immp.ConfigError("Hook reference '{}' is not an IdentityHook"
                                           .format(self.config["identities"])) from None
                identity = identities.find(clone.user)
            name = None
            if self.config["name-format"]:
                if not Template:
                    raise immp.PlugError("'jinja2' module not installed")
                tmpl = Template(self.config["name-format"])
                name = tmpl.render(user=clone.user, identity=identity)
            elif identity:
                name = "{} ({})".format(clone.user.real_name or clone.user.username, identity.name)
            if name:
                clone.user = copy(clone.user)
                clone.user.real_name = name or None
                if identity:
                    clone.user.username = clone.user.username or identity.name
        queue = []
        # Just like with plugs, when sending a new (external) message to all channels in a sync, we
        # need to wait for all plugs to complete before processing further messages.
        async with self._lock:
            for synced in self.channels[label]:
                if not (origin and synced == origin.channel):
                    queue.append(self._send(synced, clone))
            # Send all the messages in parallel, and match the resulting IDs up by channel.
            ids = dict(await gather(*queue))
            return self._cache.add(SyncRef(ids, source=msg, origin=origin))

    def _replace_msg(self, channel, msg, sending):
        if not isinstance(msg, immp.SentMessage):
            return msg
        try:
            # Given message was a resync of the source message from a synced channel.
            ref = self._cache[msg]
        except KeyError:
            # No match for this source, replace with an unqualified message.
            return immp.Message.from_sent(msg)
        log.debug("Found reference to previously synced message: {}".format(repr(ref.key)))
        if ref.ids.get(channel):
            # Return a reference to the transport-native copy of the message.
            at = ref.source.at if isinstance(ref.source, immp.SentMessage) else None
            return immp.SentMessage.from_abstract(ref.source or msg, id=ref.ids[channel][0],
                                                  at=at, channel=channel)
        else:
            return immp.Message.from_sent(msg)

    async def before_receive(self, sent, source, primary):
        await super().before_receive(sent, source, primary)
        # Attempt to find synced sources for referenced messages.
        sent.reply_to = self._replace_msg(sent.channel, sent.reply_to, False)
        for i, attach in enumerate(sent.attachments):
            if isinstance(attach, immp.Message):
                sent.attachments[i] = self._replace_msg(sent.channel, attach, False)
        return sent

    async def on_receive(self, sent, source, primary):
        await super().on_receive(sent, source, primary)
        try:
            label = self.label_for_channel(sent.channel)
        except immp.ConfigError:
            return
        async with self._lock:
            # No critical section here, just wait for any pending messages to be sent.
            pass
        if sent.deleted:
            # TODO: Sync deletions across channels.
            return
        try:
            ref = self._cache[sent]
        except KeyError:
            log.debug("Incoming message not in sync cache: {}".format(repr(sent)))
        else:
            if ref.revision(sent):
                log.debug("Incoming message is an update, needs sync: {}".format(repr(sent)))
            else:
                log.debug("Incoming message already synced: {}".format(repr(sent)))
                return
        if not self.config["joins"] and (source.joined or source.left):
            log.debug("Not syncing join/part message: {}".format(source.id))
            return
        if not self.config["renames"] and source.title:
            log.debug("Not syncing rename message: {}".format(source.id))
            return
        log.debug("Sending message to synced channel {}: {}".format(repr(label), sent.id))
        ref = await self.send(label, source, sent)
        # Push a copy of the message to the sync channel, if running.
        if self.plug:
            clone = copy(source)
            clone.id = ref.key
            clone.channel = immp.Channel(self.plug, label)
            self.plug.queue(clone)

    async def before_send(self, channel, msg):
        await super().before_send(channel, msg)
        clone = copy(msg)
        # Attempt to find synced sources for referenced messages.
        clone.reply_to = self._replace_msg(channel, msg.reply_to, True)
        clone.attachments = []
        for attach in msg.attachments:
            if isinstance(attach, immp.Message):
                clone.attachments.append(self._replace_msg(channel, attach, True))
            else:
                clone.attachments.append(attach)
        return (channel, clone)
